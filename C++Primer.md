Fuck C++
1. C++ Prime Plus
2. <font color = pink>C++ Primer</font>
3. 
4. 
5. 
6. 

# C++ Primer
pages:764
date:2023/11/13
last update:2023/12/8 15:56 Full Combo!

## 

### 第一章 开始

使用文件重定向（p19）
在命令行中 program name <infile >outfile
从infile中获取输入流，输出流写入outfile

<font color = green>End of Chapter</font>

## C++ 基础

### 第二章 变量和基本类型

/ascII只读取前三位， /x1234读取后面所有位数，表示一个16位字符（p37）

初始化不是赋值，初始化的含义是创建一个对象时给予一个初始值，而赋值的含义是对原有对象擦除然后重写，这意味着需要对原有对象进行处理并且额外考虑给自身赋值的情况，这一点在构造函数中可见一斑（p39）

C++如何处理未初始化的值（p41）
* 对类
    - 调用默认构造函数，默认构造函数不对类里的内置类型成员进行处理，对类的类成员或者继承的子类调用它们的默认构造函数，C++11允许了类内初始化
* 对内置类型
    - 在函数外：默认为0，如全局变量
    - 在函数内：不进行处理，未初始化变量的值取决于所在位置本来的值，使用这样的变量是不安全的

声明和定义（p41）
* 声明和定义的区别为C++分离式编译提供了支持
* 声明
    - 告知文件有这样一个变量，只有声明后才能使用这一个变量，声明不生成变量的实例，不分配空间，不隐式实例化模板，允许多次声明
* 定义
    - 创建变量的实例化，分配空间，只能进行一次定义（区分定义和赋值）
    - 普通变量声明时会进行初始化（即使如前一条所说，初始化可能没有任何效果），指针变量声明时对指向的东西无定义
    ```C++
    int j;//声明并定义
    extern int i;//声明
    ```

因为C++为标准库的保留，不能使用的命名：（p42）
* 不能出现连续两个 '_'
* 不能以'_'+大写字母 开头
* 函数体内不能'_'开头

指针可能指向的内容（p47）
1. 对象
2. 同一对象的下一地址
3. 无效指针
4. 空指针(0)
1和2的例子是指向数组的指针和指向数组的第一个值的指针，'=='会将它们判定为相等，但是它们有不同的意义
```C++
//example
int a[3];
a == &a; //true
a++ != (&a)++;//true
```
指针本身在内存里实际上都是一样的大小，但是因为其指向的内容而有类型上的差异

可以使用const引用对常量进行引用，虽然不知道有什么意义（p55）

constexpr 常量表达式，必须在编译时就能计算出来，使用constexpr声明指针是顶层const，只对指针有效，constexpr主要用于判定表达式是否为常量（p58）
constexpr指针只能指向0，nullptr或者固定位置的对象

tips: 顶层const和底层const
- 顶层const：指指针本身是一个常量
- 底层const：指指针认为指向的是常量，无法从指针修改这个值

typedef和using不是define，不要尝试使用直接替换来理解变量类型（p61）
```C++
typename char* pstring;
const pstring cstr = 0;//这是一个顶层const，cstr是一个值为0的常量
const pstring* ps;//指向指针常量的指针
```

auto和初始值的类型有时并不完全一样（p61）
* 会去到引用，类型实际是被引用的那个类型，这是理所当然的
* 会忽略顶层const，即去掉值本身的const，但如果auto一个指向const的指针，那么底层const不变
* 可以前面加const明确保留顶层const
* auto引用保存顶层const，其实并不混乱，比较引用是别名而普通·的赋值只是给一个其他的变量赋值
* 如果用auto声明多个变量，auto所指必须相同
    ```C++
    const int a = 1;
    auto c = a, &b = a;//error
    //非常的amazing啊，同样用a推导auto，获得了不同的结果，原因在于c忽略了顶层const而b没有，导致c是int，b是const int&，auto推导出现了矛盾
    ```
* 其实auto是聪明的类型推导，而不是类型复制，它会自动去掉一些可能不被需要的特性，比如引用，很多情况下声明一个auto变量并不是想要一个对其他值的引用

与上一条相对，看看decltype（p62）
* decltype返回的类型包括引用和顶层const
* 如果想要去掉引用：decltype(r + 0)，表达式的结果显然是非引用类型
* 对指针解引用会得到引用类型：decltype(*p)，会得到引用类型
* decltype((exp))会必定得到引用，(exp)会被视为能作为赋值语句左值的特殊表达式
* 所幸，无论是auto还是decltype，现代编译器都可以直接看到转换的类型，只需要多加小心即可

为什么类定义的{}后要加';'？这是从C继承来的，C的struct默认可以在定义后声明变量，类似于struct A{...} a;但显然这是不被推荐的做法（p65）

预处理变量无视C++语言中关于作用域的规则（p68）

<font color = green>End of Chapter</font>

### 第三章 字符串、向量和数组

size()函数返回的必定是一个无符号值，与负数int比较时会把int转为uint，应该避免size()与int比较（p79）

可以使用'+'将string相加，或者string和字面字符串相加，但一个+两边至少有一个string（考虑操作符重载还是很好理解的）（p81）

C++标准并不要求标准库检测下标的合法性，使用::size_type类型可以保证下标是正数，但需要保证下标不要越界（p85）

对类的初始化，可以使用(){}，()只支持构造函数，{}支持构造函数和列表初始化，但是优先列表初始化（p89）

vector在填入数据是能自动进行高速增长，并且这种增长比直接在一开始定义长度效率更高，除非所有数据相同。如果要一个一个填入数据，最好在一开始声明空vector（p91）

for(item i : vector<item>)循环中不能改变vector容量，但凡使用了迭代器的循环体，都禁止进行可能改变指向对象容量的操作，因为可能会使迭代器失效（p91）

并不是所有stl定义类型都定义了下标和><，但都定义了迭代器和== !=，因此使用auto i = stl.begin(); i != stl.end(); i++进行遍历更好，除了普通的迭代器，C++还定义了const_iterator，类似于指针的底层const，指向常量的迭代器必须为const，begin和end也会根据是否为常量返回不同的迭代器，也可以通过cbegin，cend主动要求常量迭代器（p97）

复杂的数组声明（p102）
```C++
int *ptrs[10];  //ok, array of ten int*
int &rtrs[10];  //invalid, elments cant be reference
int (*pitrs)[10];//ok, a point of an array of ten int
int (&ritrs)[10];//ok, a reference of an array of ten int
```

在大多数情况下，使用数组名实际上是在使用指向数组头对象的指针，使用auto判断数组类型也是对应的指针，但使用decltype判断得到的是原来的数组类型。为了和迭代器匹配，C++11定义了函数begin()，end()用来获取内置类型数组的begin和end，范围与迭代器中一致（p106）

两个指针相减会得到一个ptrdiff_t类型，和size_t一样定义在cstddef中，并且ptrdiff_t是一个有符号值，空指针也能进行指针运算，但只能与0进行计算（p107）

内置指针类型的下标运算符的参数是有符号数，这一点与vector和string的下标是无符号数不同（p108）

对大多数应用来说，使用标准库string要比使用c风格字符串更安全更高效（p110）

可以使用以空字符结尾的字符串初始化string，参与string运算(只能参与一个)，不能用string初始化字符串，相对的，提供了string.c_str()函数，返回一个const c字符串，然而如果后续对string有所更改这个字符串自然也就失效了。可以使用内置数组初始化vector，传入的参数是指向数组内容的起止指针，可以传入部分数组（p111）

要使用范围for循环处理数组时，除了最内层，其他所有外层都应该使用引用，否则auto会视为指针（p114）

<font color = green>End of Chapter</font>

### 第四章 表达式

使用decltype的时候，如果表达式返回一个左值，得到的结果是对应类型的引用，如果返回一个右值，得到的才是原本的类型（p121）

只有四个符号规定了求值顺序: && || , (? :)，求值顺序和优先级，结合性无关，如果没有规定顺序的表达式的对象之间互相有影响，得到的程序是错误的。在拿不准优先级时最好使用括号，实际上为了程序的可读性，在一些不常用的优先级上都应该使用括号。如果改变了某个运算对象的值，在表达式的其他地方不要再使用这一对象，除非这一改变对象的子表达式本身就是表达式的对象，如*++ipter（p123）     
如果你认为你不会在这样的问题上犯错，（p133）提供了一个可能的例子
```C++
*beg = toupper(*beg++);//error

//四个运算符的求值顺序
&& : 如果左边为true才计算右边
|| : 如果左边为false才计算右边
,  : 从左向右
?: : 先判断表达式，只计算其中一个结果
```

当一元正负号作用于算数值时1，返回一个提升后的对应副本。bool值不应该参与运算，正如（p124）
```C++
bool b1 = true;
bool b2 = -b1;  //true;
//首先，负号让b1提升到int，也就是int的1，然后取负号，变为-1，又因为赋值给bool变量，类型转换为true
//如果想获得b1的相反值，你应该：
bool b3 = !b1;  //false;
```
/ %的正负性（p125）     
(-m)/n == m/(-n) == -(m/n); (-m)/(-n) == m/n   
(-m)%n == -(m%n); m&(-n) == m%n; (-m)%(-n) = -(m%n)

进行比较运算时除非比较的是bool类型，否则不要把true flase作为运算对象（p128）
```C++
int a = 2;
if(a == true)//false
//还是因为类型提升，这个表达式会把true提升到int，也就是1，这样本来判断a非0变成了a必须为1
```

对于多重赋值，每个赋值要分别考虑合法性，比如（p129）
```C++
int a;
int *p;
a = p = 0;//invalid
//虽然a，p都能被赋值为0，但是a和p之间不能进行隐式转换
```

除非必须，否则不要使用递增递减运算符的后置版本，特别是对于复杂的对象。后置版本会进行临时对象的创建和析构（p132）

->只能作用于指针，返回对象时左值，.作用于左值，返回左值；作用于右值，返回右值（p134）

? :的嵌套会使程序可读性剧烈下降，? :优先级很低，不对其使用括号可能会让不同的代码各显神通（p135）
```C++
cout << ((grade < 60)? "fail": "pass" );//as you want
cout << (grade < 60)? "fail": "pass";//输出(grade<60)，也就是0或1
cout << grade < 60? "fail": "pass";//error，试图使用cout和60进行比较

//同样，虽然在这里例子里没问题，但是你也不应该省略?前比较表达式的括号
int grade = 59;
int b = 10 + grade < 60 ? 0 : 1;//1
```

关于符号位如何处理没有明确规定，因此强烈建议将移位运算符用于无符号类型。（p136）

可以通过sizeof(type)或sizeof expr获取变量的大小，类型为size_t，sizeof不会对表达式进行计算，因此可以sizeof Class::data直接获取类成员大小或者sizeof *p即使p是无效指针。sizeof不会把数组名视为指针，而是会返回整个数组的大小，但是如果数组名作为函数参数，在函数中生成的临时变量仍然是一个指针，因此还是需要在参数传入大小。sizeof不会实际计算vector和string的元素占了多少空间，只会返回该类型固定部分的大小（注意真实的内容是储存在堆里，对象中只保存了一个指针）（p139）

const_cast只能去除底层const，如果指向的内容本来就是const（顶层const），无法使用const_cast，对所有的转换类型，如果<type>是引用类型，则返回左值，在（p209）提供了一个常用的示例，通过const_cast重载非const引用的函数，使它在const版本返回的值能去除底层const（p145）

<font color = green>End of Chapter</font>

### 第五章 语句

如果需要为某个case分支定义并初始化一个变量，我们应该把变量定义在case块内，从而确保后面的所有case标签都在变量的作用域之外（p163）
```C++
case true:
    int a;
    int b = 1;
    string s;
    break;
case false:
    a = 1;//ok
    b = 2;//error，跳过初始化
    cout<<s;//error，s是隐式初始化
    break;
```
整个switch在同一个作用域里面，编译器的错误实际上是跳过了case里的初始化，switch和goto都不能跳过变量的初始化，合理的做法应该是
```C++
case true:
{
    int a = 0;
    int b = 1;
    break;
}
case false:
{
    int a = 2;
    int b = 2;
    break;
}
//避免这种同名变量的冲突
```

范围for循环等价于（p169）
```C++
for(auto beg = v.begin(), end = v.end(); beg != end; ++beg)
{
    auto& r = *beg;
    //...
}
```
因此，只有有begin，end的类才可以使用范围循环，并且不能再循环中添加或删除元素，因为会使end失效

try语句示例（p174）
```C++
try{
    //if...
    throw runtime_error("What happened");
}catch (runtime_error err) {
    //...
    cout<<err.what();
}
```
C++提供了一些标准异常类，其中exception, bad_alloc, bad_cast只能进行默认初始化，而其他的类需要提供字符串进行初始化。异常类只定义了一个what()成员函数，返回一个c风格字符串，内容和初始化一致，如果是默认初始化，内容由编译器决定。如果throw抛出的异常找不到对应的catch块，就会调用标准库函数terminate终止程序。

<font color = green>End of Chapter</font>

### 第六章 函数

int main(int argc, char *argv[]);当为main传递参数时，argv[0]指向的是程序的名字，真正的参数从argv[1]开始，argc保存参数的个数，argv最后的一个字符串（argv[argc]）为\0（p197）

使用初始化列表作为形参可以传递任意数量的参数，这也是vector这样类的构造函数之一的形参（p198）
```C++
void error_mag(initializer_list<string> il)
{
    for(auto &elem : il)
        std::cout << elem << " ";
}

error_mag({"hah", "djasl", "djals"});
```
初始化列表的形参是const，互相赋值和拷贝不会拷贝列表元素，而是共享。有size，begin，end函数

关于函数重载的参数类型，总的原则是不要让函数调用时出现可能的二义性，比如值传递的是否const和实参的是否const无关，但是引用传递的底层const则和实参有关（208）

C++中，名字查找发生在类型匹配之前。换句话说，C++在处理不同作用域的函数重载时，先在最近的作用域找到所有同名的函数，然后再进行类型匹配，而该作用域外的所有函数将被忽略，即使作用域内的函数不足以满足匹配要求（p211）

可以通过重复声明添加默认实参，但只能修改本来没有默认实参的值（p212）

inline函数和constexpr函数通常放在头文件，他们的共同特点是都不在运行时进行调用，inline是直接在编译时把调用函数的地方直接替换，constexpr是在编译时返回常量表达式（被隐式的声明为内联），但constexpr不一定只能返回常量，比如可以在实参是常量表达式时返回sizeof()。此外constexpr只能有一个return，形参必须是字面值类型。（p214）

使用decltype获取函数类型得到的不是指针，要手动加*，对函数类型的声明：int(int*, int)，同样不是指针，应该int(\*)(int\*, int)(223)

<font color = green>End of Chapter</font>

### 第七章 类

对象成员函数的this指针实际上是一个顶层const，在成员函数参数列后加const实际上是添加了底层const（p231）

构造函数不能是const的，但显然，const对象也可以使用构造函数，这是因为const属性是在构造函数完成初始化过程才获得的（p235）

在声明要使用默认构造函数，即=default时，可以在类定义内(inline)，也可以在类定义外(非inline)（p237）

类的友元声明并不是一个真正的函数声明，只是声明了friend关系，换句话说，如果希望在类中使用这个友元函数，还需要在类前面先声明一次（p242）

友元的关系不能传递，正如之前所说，友元只是单项的承认，和另一方是无关的，自然，A认为的friendB不能让A也认可B自己的friend。成员函数可以作为友元，但需要仔细处理声明和定义的顺序：
* 定义被类A认可的friend函数c所在的类B，包括对c的声明但是不能定义，在c使用A的成员之前必须先声明A
* 定义类A，包括声明函数c的friend关系
* 定义函数c（p252）

可以在类中定义和类外同样名称的变量，但不能定义同样名称的类型（p255）

聚合类：（p266）
* 所有成员public
* 没有定义任何构造函数
* 没有类内初始值
* 没有基类，没有virtual函数
* 其实就是c的struct，提供了显式{列表}初始化，如果列表内元素不足，后面的进行值初始化

字面值常量类（p268） 不知道有啥用

类的静态成员（p269）        
不能在构造函数中初始化，应该在类的外部定义，只能定义一次，应该放在类的成员函数定义的那个文件里。如果要在类中初始化静态成员，应该为constexpr。静态成员可以是不完全类型，也可以作为构造函数的实参

<font color = green>End of Chapyer</font>

## C++标准库

### 第八章 IO库

如果一个程序异常终止，输出缓冲区不会刷新，它所输出的数据可能留在输出缓冲区等待打印，虽然没有输出，但是代码已经执行了（p282）

输入输出流（p283-287）
* fstream和sstream都是由iostream继承而来，因此定义了os<< is>>的类型也可以被它们使用
* 输入输出是敏感的行为，因此，当程序检测到错误的输入输出时，会将输入输出流错误码置位，并使之失效，也可以手动改变错误码
* 对已经启用的输入输出流，无法在为它打开文件，在块结束时，流会像其他变量一样被销毁，同时关闭文件
* 在打开文件时可以选择打开文件模式，如果希望保留已有文件的内容，需要手动设置app(写操作前定义到文件末尾)，或是in(读模式)，否则ofstream打开默认为trunc(截断文件)，会丢弃已有数据

使用string流处理复杂的信息，特别是有多层架构的信息，需要先处理中间类型（p289）

<font color = green>End of Chapter</font>

### 第九章 顺序容器

迭代器范围指的是一个左闭右开区间，正如begin-end表示从第一个元素到最后一个元素(end指向的是最后一个元素的后一位)（p296）

如果要将一个容器拷贝给另一个容器，容器的类型必须完全相同。使用迭代器的拷贝不是容器拷贝，而是把那个迭代器范围里的值一个个用来初始化（p300）

构造容器
- swap：应该统一使用非成员函数版本的
- assign：支持所有的构造方式，array没有
- 关系运算符：和string类似，前提是元素类型支持相应的关系运算
- push_back， push_front：返回void
- insert(p,t)在p(迭代器)位置插入t，(p,n,t)插入n个t，(p,b,e)插入b到e之间的元素，插入操作会使所有过去声明的迭代器失效，因此b和e不能是目标容器的迭代器(p,{il})插入初始化列表，都返回插入的第一个元素迭代器，如果没有插入就返回p。插入的实际顺序在p之前，p以及之后的元素依次后退。随机访问的插入会比上面两个函数慢很多。
- emplace：调用元素类型的构造函数，直接在容器空间中创建对象，也是用来跳过临时对象的

访问元素
- back() 尾元素的引用
- fornt() 首元素的引用
- []越界则无定义，严重的程序设计错误,at越界则抛出out_of_range异常
禁止对空容器使用back和front

删除元素
- pop_back
- pop_front
- erase(p) 删除p指向的元素，(b,e) 删除指定范围的元素，返回最后一个被删除元素后的迭代器
- clear 删除所有元素返回void
- 删除首位之外的deque元素会使所有迭代器引用指针失效，删除vector和string元素只会使被删除点之后的失效，在删除元素之前程序应该保证元素是存在的

forward_list            
链表的插入和删除需要更改前一个节点的后继指针，而单项链表没有直接访问前一个节点，因此无法像其他容器一样在指向节点进行操作，而是对指向节点的后继进行操作
- before_begin() 返回首元素之前的迭代器(rbegin)
- insert_after
- emplace_after
- erase_after

改变容器大小
- resize(n)
- resize(n,t)
调整大小，元素不足则补全(t或者值初始化或默认构造函数)，元素过多则删除，和增加删除一样(影响情况也是一样的)会导致迭代器指针引用失效

迭代器引用指针失效          
对不同容器进行增删操作会造成容器的迭代器指针引用不同程度的失效，这里列举还不太熟悉的deque，其他的见（p315）
* 迭代器引用指针失效本质还是数据存储位置的改变，如果了解vector，string容量增长的原理，list的实现，这些性质还是容易理解的
* 添加元素后
    - 对deque，插入首尾位置之外，全部失效；在首尾添加，迭代器失效，其他的不会失效
* 删除元素后
    - 对deque，首尾位置之外，其他的全部失效；尾元素，尾后迭代器失效，其他不受影响；首元素，不受影响
* 因为迭代器，特别是end很容易失效，因此在循环中不要试图保存一个end迭代器一直用，而应该每次调用，毕竟正因为考虑到这点，标准库实现中end操作都很快

管理容量（vector string）
- shrink_to_fit 压缩到刚好容纳（deque也有）
- capacity 容量 注意与size的区别，二者几乎是独立的，还要注意at和[]的范围是由size决定的，和capacity无关
- reserve 分配容量，如果比现有容量小，不进行任何操作。注意resize只改变元素个数，不会减少容量，当然容量不够会扩容

关于string
* 构造
    - string(cp,n) cp中前n个字符的拷贝
    - strng(s2,pos2) s2从下标pos2开始的字符拷贝
    - string(s2,pos2,len2) s2从下标pos2开始的len2长的字符拷贝，至多拷贝到末尾
* s.substr(pos, n) s中从pos开始n个字符的拷贝
* assign insert erase支持下标和c风格字符串
* append(string) 在末尾插入
* replace(p, len, str) 把从p开始的len长度字符串替换为str
* 太多了，记不住一点，直接看（p323）

* 搜索函数 这一系列函数返回string::size_type，注意这是一个unsigned
    - find rfind 第一次出现和最后一次出现
    - find_first_of find_last_of 字符串中任何一个字符最先最后出现
    - find_first_not_of find_last_not_of 第一个最后一个不在字符串中的字符位置
    - 参数 查找内容和从哪里开始
        * c, pos
        * s2, pos
        * cp, pos
        * cp, pos, n（这里pos和n无默认值，查找cp的前n个字符）
* compare 主要是方便处理字符串内的比较（p327）
* 数值转换 string和内置数值内型的转换，都是..to..()（p328）

适配器：容器函数迭代器都有适配器，接收一个已有的类型，使之看起来像是一个新类型。标准库据此实现了stack，queue和priority_queue
有点类似私有继承has-a的关系

<font color = green>End of Chapter</font>

### 第十章 泛型算法

C++标准库容器定义了尽量少的函数，而更多的算法是通过泛型算法实现的，这些算法无需考虑具体的容器和类型，只使用迭代器，不使用容器本身的算法，因此它们自身不可能改变容器的大小

泛型算法和容器无关，因此可以对两个不同的容器进行操作，只要它们的迭代器有对应功能，但相对的，防止越界和不存在的访问是程序员的责任

算法类型
* 只读容器的算法 应该使用cbegin，cend
    - find accumulate
    - find_if
* 写容器算法 写入的序列应该小于给定范围
    - fill fill_n ->递增后的迭代器
    - copy replace
* 重排容器算法
    - sort unique->最后一个不重复元素之后的位置 stable_sort

参数类型
* range, vals
* fir_range, sec_begin，默认第二个大小不小于第一个范围，如果希望在范围外插入应该使用插入迭代器back_inserter
    - range = begin , size
* src_range, back_inserter(des), vals 一些函数的copy版本，区别于直接覆盖

* 定制操作
    - range, predicate

lambda必须永远包含捕获和函数体，没有默认参数（p346）
捕获变量是在创建时拷贝，参数才是调用时拷贝（p350）
必须保证lambda执行时，捕获的引用变量存在（p351）
隐式捕获[=, identifier_list] [&, identifier_list] (p352)
如果要修改捕获变量，对值捕获应该加mutable，对引用捕获被引用的值不能是const（p353）

bind函数，头文件functional（p354）          
auto newCallable = bind(callable, arg_list);
arg_list: parameters(引用请用ref()/cref()), std::placeholder::_n(占位符，从1开始，表示调用时的第n个实参)

再探迭代器（p357-365）
* 插入迭代器
    - 操作
        * it = t 执行插入操作
        * *it, ++it, it++ 不做任何操作
    - 类型(des, pos(inserter))
        * back_inserter
        * front_inserter
        * inserter it = t后指向的元素不变，换句话说插入后位置++
* 流迭代器
    - istream
        * istream_iterator<T> in(is); 绑定输入流
        * istream_iterator<T> end; 默认初始化为eof
        * == !=
        * *in, in->mem
        * ++in, in++
    - ostream
        * ostream_iterator<T> out(os); 绑定输出流
        * ostream_iterator<T> out(os,d); 在每个输出后加d，d是一个c风格字符串
        * out = val 用<<写入val到os，写入后位置++
        * *out, ++out, out++ 不做任何操作
        * *out++ = val和 out = val完全等价，但前者和其他迭代器使用方式一致且更可读
        * 可以直接copy(vec.begin(), vec.end(), out_iter)
* 反向迭代器r
    - 要求：定义了--操作 forward_list 流迭代器没有反向迭代器
    - 反向迭代器表示的范围也是逆序的
    - .base()返回对应的正向迭代器，具体来说是该位置的后一个位置，反向迭代器和对应正向迭代器表示的范围完全一致，只是逆序
* 移动迭代器（移步第十三章）

因为链表数据结构的特殊性，泛型的一些算法无法使用或是性能太差，链表有一些自己的成员函数，特定容器如果实现了自己的成员函数，应该优先使用成员函数（p369）
* merge, remove, reverse, sort, unique
* splice
    - (p, lst2)，把lst2移动到p，不能是同一个链表
    - (p, lst2, p2)，把lst2中p2移动到p，可以是同一个链表
    - (p, lst2, b, e)，把lst2给定范围移动到p，可以是同一个链表，但范围不能包含p
* *使用链表的算法时一定要区分链表和前向链表的迭代器实际指向的哪里*
* *链表版本的算法会更改容器大小，而泛型算法是不会更改容器大小的，即使是remove这样的函数也只是值的移动，此外，在算法中使用插入迭代器改变了大小是因为它本身就是容器的成员* 

<font color = green>End of Chapter</font>

### 第十一章 关联容器
1. set map
2. multi +
3. unordered_ +

关联式容器可以使用列表初始化和范围拷贝，但对非multi，列表里不能有相同值，即使提供了有相同元素的拷贝，初始化后也会删除这些相同的值（p377）

有序容器的关键字类型必须提供严格弱序的比较，即“行为正常”的<运算符或函数（p378）
```C++
//将比较函数绑定到关联运算符
set<Sales_data, decltype(compare)*> bookstore<compare>;
```

pair是一个键值对，保存两个可定义类型的值，成员变量是public的，允许比较和判断相等，类型可以自动推导，使用make_pair(v1, v2)（p380）

关联容器元素的类型（p381）
- set<>::key_type == set<>::value_type
- map<>::key_type = fir, map<>::mapped_type = sec, map<>::value_type = pair<const key_type, mapped_type>
- 关联容器的迭代器指向它们的value_type，他们的关键字都不能改变，但是map的mapped_type可以改变
- 正因为关联容器的元素存在const，所以关联容器一般不使用泛型函数，除了被当做src或des，而是使用自己的成员函数

插入操作（p385）
同样有insert和emplace，用法一样，但一般不用迭代器定位，实际上关联容器的插入本来也不应该在某个地方插入，而是插入key后平衡树自动排序，对于参数(p,v)，实际上指的是指定从p开始搜索应该插入的位置（不过究竟是指的子树还是后继呢？）      
但对于返回值
    - 插入一个 返回pair<迭代器, bool 是否成功(非重复)>
    - 插入一个范围 返回void
    - 定位插入一个 返回迭代器

删除操作（p386）
- c.erase(k) 删除所有关键字为k的元素，返回size_type表示删除的个数
- c.erase(p) 删除迭代器指定的元素，返回删除元素之后的迭代器
- c.erase(b, e) 删除范围，返回e

下标/访问（p387/388）
- c[k] 如果没有关键字k，则添加并且值初始化
- c.at(k) 如果没有关键字k，抛出out_of_range异常
- 因为下标运算可以在容器中插入元素，并且返回引用，所以只能对非const map使用下标和at，如果只是想访问而不想改变容器，最好用find

- c.find(k) 返回第一个关键字k的迭代器
- c.count(k) 返回关键字k的个数
- c.lower_bound(k) 返回指向第一个关键字 >= k的迭代器，下同
- c.upper_bound(k) >
- c.equal_bound(k) 返回pair fir和sec确定了关键字k元素的范围
- multi中相同关键字的元素存储在相邻的位置，因此使用find和count可以轻松完成遍历，也可以使用lower_bound和upper_bound绑定范围

无序容器通过key的hash指向对应的桶，通过桶来管理，容器的质量取决于桶和桶中元素的数量以及hash的质量。作为关键字的类型需要提供自己的 == 和 hash 当然也可以绑定成员函数。所有的内置类型，string，智能指针都可以直接定义（p394）

<font color = green>End of Chapter</font>

### 第十二章 动态内存

智能指针shared_ptr和unique_ptr的操作（p401）
* shared_ptr<T> sp 声明空智能指针
* p 若指向一个对象，返回true
* *p 解引用
* p->mem 指向对象的成员函数
* p.get() 返回保存的指针
* swap(p,q)，p.swap(q) 交换指针
* shared_ptr独有
    - make_shared<T>(args) 返回指向args初始化对象的shared_ptr
    - 拷贝构造，赋值构造
    - p.unique() 若指向对象的智能指针数量为1，返回true
    - p.use_count() 返回与p共享对象的智能指针数量
即使使用了shared_ptr，也只是保证在智能指针离开作用域时释放动态内存，如果智能指针仍然存在，动态内存不会被自动释放

new动态分配使用默认初始化，如果要对内置类型值初始化，加空的参数列表()，若参数列表只有一个初始化，就可以使用auto由这个初始化器推断类型（p407）
```C++
auto p1 = new auto(obj1);

//动态分配const
const int *pci = new const int(1024);
//动态const也可以被delete

//若分配失败
int *p1 = new int;//抛出std::bad_alloc
int *p2 = new (nothrow) int;//本质上是定位new，返回空指针
```

为什么要使用智能指针（p411）        
动态分配内存有这样几个问题：
* 在使用完动态内存后忘记delete
* 对同一动态内存多次delete
* delete后继续使用指向原地址的指针
在实际应用中，当有多个指针指向同一动态内存时，delete后修改每个指针为0是困难的

智能指针可以使用new分配的动态内存进行初始化，但不能用来赋值，智能指针也可以接受普通指针，但需要指定替代delete的函数对象，以下为shared_ptr的初始化和reset（p412）
```C++
shared_ptr<T> p(q);
shared_ptr<T> p(u);//使用unique_ptr初始化
shared_ptr<T> p(q, d);

p.reset();//解除当前绑定
p.reset(q);//转移绑定到q
p.reset(q, d);//转移绑定到q，并且按定义的d处理当前绑定

//常见用法
if(!p.unique())
    p.reset(new string(*p));
//在p和其他指针共享同一内存时拷贝一个新的
```

unique_ptr（p417）
* unique_ptr不支持赋值和拷贝，注意将赋值拷贝与reset区分开
* unique_ptr<T, D> u(d) 绑定delete D:decltype(fun)*
* u = nullptr; u.reset(); u.reset(nullptr); 释放指针
* u.reset(q) 释放后指向q
* u.release() 放弃控制权，返回指针，没有释放
* 指针控制权转移：u.reset(q.release());
* 不能拷贝的规则有一个例外，可以拷贝或者赋值一个将要被销毁的，比如返回值

weak_ptr（p420）
* weak_ptr绑定在share_ptr上，不增加共享计数，不参与内存控制，只共享访问
* weak_ptr<T> w(sp); 使用share_ptr初始化
* w = wp/sp;
* w.reset();
* w.use_count(); 共享的sp的共享计数
* w.expired(); 指向的内存是否被释放
* w.lock(); 若指向内存存在(w.expired() = false)返回一个shared_ptr，否则返回空
* 对weak_ptr的正确访问：if(shared_ptr<int> np = wp.lock()) {}

动态数组不是数组类型，只是指向堆中某一段连续内存的指针，因此不包括数组维度，自然无法使用begin，end，范围for循环，同时不能用auto自动推断（p424）

动态分配一个空数组是合法的 char *cp = new char[0];返回一个合法的非空指针，但不指向任何东西，不能解引用，类似于尾后迭代器                
delete[]删除动态数组时按逆序删除（p425）

unique_ptr支持指向动态数组，并且使用下标直接访问。而shared_ptr不支持，因为没有对应的delete[]，除非自己定义删除器[](int *p){delete[] p;}; 即使定义了删除器，shared_ptr也不支持下标访问，只能用get转回原指针后解引用（p427）          
由此看来，unique_ptr和shared_ptr并不只是是否共享的区别，各自的删除方式和管理方式也有所区别

使用memory里的allocator在堆中分配对象无关的空间，把动态分配和对象构造分离开来（p428）
* allocator<T> a; 模板构造，a用来动态分配类型T
* a.allocate(n); 分配一段原始内存，和类型无关，只是大小为能保存n个类型T
* a.deallocate(p,n); 移除n个T的内存，从p开始，p必须是先前allocate返回的，必须先对所有对象调用destroy
* a.construct(p, args); 在p位置构造类型T
* a.destroy(p); 对p指向的对象析构

在给定的内存空间（allocator分配的）创建元素，对未初始化空间的赋值（p429）
* uninitialized_copy(b,e,b2) 把be迭代器之间的对象拷贝到b2
* uninitialized_copy(b,n,b2) 把b迭代器之后n个对象拷贝到b2
    - copy返回最后一个构造元素之后的位置
* uninitialized_fill(b,e,t) 在be迭代器之间的原始内存填满t
* uninitialized_fill(b,n,t) 在b迭代器之后n个原始内存填满t

<font color = green>End of Chapter</font>

## 类设计者的工具

### 第十三章 拷贝控制

拷贝构造发生在什么时候（p441）              
拷贝发生在用一个已经实例化的对象对新对象初始化时
```C++
string a(10, ' ');//直接初始化
string b(a);//使用拷贝构造函数的直接初始化

string c = a;//拷贝初始化
string d = "djsaldjsa";//拷贝初始化
//以及
//值传递的实参
//值传递的返回值
//正因为值传递实参时会调用拷贝构造，拷贝构造自己的形参才是必须为引用，一般为const
```
注意拷贝构造的形参永远是自身类型的引用，因此如果构造函数是explicit的，使用直接初始化和拷贝初始化就不是等价的了

赋值构造发生在什么时候（p444）                  
赋值发生在将一个已经实例化的对象赋值给另一个已经实例化的对象时，注意两个对象都已经实例化。赋值构造是对操作符的重载，不是构造函数，不能使用初始化列表，不能使用委托构造函数（因为this已经实例化）

析构函数发生在什么时候（p445）                  
对象被销毁的时候，析构函数有函数体和析构部分，析构部分在函数体执行后隐式执行，析构函数体并不执行成员销毁。注意容器在销毁时会对所有元素执行构造函数，对象销毁时也会执行对象成员的析构函数

使用delete（或private）和default来删除函数和使用默认函数，二者有一点区别，删除必须在第一次声明时指定，而默认可以推迟到定义时，可以删除其他函数，比如继承时子类的函数。不可以删除析构函数，那样会使得对象无法销毁，因此无法定义类的实例或者临时变量，不能成为其他类的成员。可以定义这样类的动态分配，但不能delete（p450）

如果一个类有数据成员不能被默认构造，拷贝，复制或销毁，则对应的成员函数将被定义为删除的，引用和const都在这一规则里受到了限制（删除了赋值构造函数），但指针不受影响（p451）

拷贝并交换（p459）
```C++
HasPtr& HasPtr::operator=(HasPtr rhs)//值传递
{
    swap(*this, rhs);
    return *this;
}
//异常安全
//可以处理自赋值
```

右值引用是左值！ 可以销毁一个移动语义源对象，也可以赋予新值，但不能使用它的值。使用移动语义(std::move)就相当于承诺不再访问原值（p472）
```C++
StrVec::StrVec(StrVec &&s) noexcept//不抛出异常
    //接管源对象的所有内存，不分配新的内存
    : elements(s.elements), first_free(s.first_free), cap(s.cap)
{
    //禁止源对象访问数据
    s.elements = s.first_free = s.cap = nullptr;
    //这和牛头人有什么区别
    //你也不希望堆为你分配更多内存进行新的拷贝吧
}
```
这里面我们声明了noexcept，这是不可以省略的，如果我们定义了不抛出异常的的函数，我们应该显示的告诉编译器，否则编译器可能不会（不敢）使用。例如，我们都知道vector的push_back函数在容量不够时会开辟新的空间保存原来的元素，原来的元素会被循环拷贝到新地址，如果在这中间出现了异常导致拷贝中断。在使用移动语义的情况下原地址的元素会遭到破坏，而标准库对push_back又有异常安全的承诺，因此标准库不会轻易使用std::move

只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所欲数据成员都能移动构造或者移动赋值时，编译器才会为他生成移动构造和移动赋值（p476）

移动右值，拷贝左值，如果类的移动构造和移动赋值被禁止，那么对右值和std::move都会被转换为拷贝（p477）

移动迭代器（p480）                      
make_move_iterator(it)返回移动迭代器，解引用生成右值引用，可以传递给算法，执行移动操作，但不检查是否适用                        
移动语义使用来减轻拷贝带来的内存压力的，在移动赋值和移动构造之外的地方，只有当确信需要移动操作并且保证安全的时候，才使用std::move

可以定义一个成员函数的右值引用版本，即拷贝和移动分开（p483）

可以对右值对象调用成员函数以及赋值，如
```C++
string s1, s2;
(s1 + s2).find('s');
s1 + s2 = "wow"
```
可以通过引用限定符禁止这种用法，通过在const限定符后那个位置加 &
```C++
class Foo{
    Foo someMem() const &;
};
```
和const限定符一样，引用限定符也可以参与函数的重载，但如果对同名函数中的一个声明了引用限定，其他的所有具有相同参数列表的所有版本同名函数都应该有引用限定，因为不指定的话左值右值都行，会出现二义性（p484）

<font color = green>End of Chapter</font>

### 第十四章 重载运算与类型转换

通常情况下，不应该重载, && || 因为重载会使运算顺序和短路求值失效，也不应该重载& 因为该运算符在类中有了内置的含义（p491）

将重载运算符放在成员函数和友元函数的区别是，友元函数的所有参数都可以被指定并且， 隐式转换，但成员函数的第一个参数是explicit的类类型（p493）

前置运算符 Class& operator++();     要检查返回值有效性              
后置运算符 Class operator++(int);   int用来重载，实际并不使用（p503）                       
显式调用：
* p.operator++()  //++p
* p.operator++(0) //p++

如果一个类有类似指针的特性，可能需要声明成员访问运算符（p504）
```C++
//指向string的指针类
std::string& operator*() const
{
    //检查指向是否合法
    return *p;//返回指向
}
std::string* operator->() const
{
    return & this->operator*();//返回指向目标的地址
}
//本质都是对绑定目标的直接调用
//注意->的显式使用
point.operator()->mem;
```

lambda表达式生成的实际上是一个函数对象，所有的值捕获会被拷贝到对象中成为成员变量。这个类不含默认构造函数，赋值构造和析构函数，是否具有拷贝/移动构造根据捕获的成员类型决定（p509）

标准库函数对象（p510）

使用function<T> f统一函数，函数指针，函数对象，lambda，只要他们的调用类型相同。用重载函数初始化function会导致二义性，但可以通过函数指针或者lambda解决（p512）
```C++
function<T> f;
function<T> f(nullptr); //显式构造空function
function<T> f(obj);
f                       //当f含有一个可调用对象时返回真
f(args);                //调用
//types 字面意思
result_type argument_type   first_argument_type second_argument_type

//T 调用形式 int(int, int) | ret(args)
```

可以在类中定义类的类型转换(应该尽量避免或者只使用一些常用的)，这个成员函数没有参数（因为是隐式转换），没有返回值声明但会返回给定类型，类型转换会带来意想不到的结果，例如
```C++
//声明
operator int() const;

//二义性
A(const B&);            //B -> A in A
operator A() const;     //B -> A in B
//无法通过显示转换解决
//和构造函数产生二义性
A(int);
A(double);
operator int() const;
operator double() const;

A a;
A b = a;

//错误使用
cin << i;
```
会变得合法(cin -> bool -> int 执行移位)                     
因此C++11引入了显式类型转换运算符（在前面加explicit）               
这样只能使用显示转换了，但有个例外，在条件语句里会将显示转换自动应用，所以才能正常使用if(cin)（p516）

<font color = green>End of Chapter</font>

### 第十五章 面向对象程序设计

派生类通过基类的构造函数为基类赋值，先对基类，然后是派生成员依声明次序进行。派生类应该遵循基类的接口，使用构造函数对基类实例化，即使语法上可以在构造函数中访问赋值基类的成员也不应该这样做                      
派生类的声明不包含派生列表，声明语句的目的是表示名字的存在和对于的类型，而派生部分算是属性了（p532）

显而易见，一个类在被继承时必须已经定义了。可以使用final禁止其他类继承这个类（p533）

关于继承关系的类型转换（p536）
* 派生类的引用和指针可以转换到基类，但本身并没有也不能转换
* 基类不能隐式转换到派生类
* 派生类向基类转换受访问类型限制

虚函数重载形参必须严格一致，返回值可以有例外，当返回类型是类本身的指针或引用时（p537）

为什么要使用override，防止在重载覆盖虚函数时把形参列表写错，然后被编译器认为是独立的重载函数（p538）

如果虚函数使用默认实参，默认实参的值是根据静态类型确定的，换句话说，使用的是基类的值。可以使用作用域运算符强制调用某一版本的虚函数，这一用法通常出现在派生类虚函数调用基类虚函数时，此时基类虚函数一般完成一些共同的任务（p539）

抽象基类就是声明了纯虚函数的基类，作为接口，不能实例化，如果派生类不覆盖自己的虚函数，派生类仍然是抽象基类。纯虚函数也可以有定义，但定义必须在类定义外。此外抽象基类并不代表是继承链的顶层，可以从非抽象基类继承抽象基类，把虚函数＝0就可以（p541）

protected保护外界对基类成员的访问，允许派生类和派生类友元访问，但只限于通过派生类进行访问，而无法通过基类（非派生类本身）访问。或者也可以说是不能访问其他基类的保护成员（p543）

成员访问和派生访问的限定是完全独立的，没有相互关系，成员访问限制决定了外部和派生类是否能访问基类，派生访问限制决定了外部是否能通过派生类访问到基类成员，此外友元的访问能力和所在类一致（p544）

友元关系不能传递，不能继承，但可以通过友元访问友元声明所在基类的继承类的基类部分，友元类的继承不具备友元的访问权限                          
派生类可以为那些他能访问的基类成员重定义访问权限，在访问权限声明后使用using（p546）

class和struct的唯一区别在于默认访问限制不同，这里的访问限制包括成员和继承（p547）

类是如何访问到一个成员的（p547 - 551）
* 从类的静态类型对应的类开始，向继承链顶层查找对应的名字
* 查找到名字后，尝试进行参数匹配
* 获得合适的匹配之后，如果是类实例，则调用静态类型的成员，如果是引用或者指针的虚函数，则根据动态类型确定调用的函数
* 如果希望在继承类中重载部分参数不同的同名函数，对其他参数类型的函数保留，使用using
* 注意名字查找是从静态类型开始的，只有一切匹配后才会尝试调用动态绑定的虚函数，因此虚函数的参数列表一定要一致
* 同名的虚函数和普通函数是区分开的，重载的同名普通函数不会覆盖继承的虚函数（即使虚函数没有在此定义）

继承类的构造函数在进行时需要向顶层迭代调用构造函数，实际的顺序是从顶层到底层逐渐完成，在这一过程中，对象处于一个未完成状态，此时对象的类和构造函数的类属于同一个，换句话说，此时调用的成员函数或者虚函数都是这个类的成员。因为底层的成员变量还未初始化，自然无法使用。对于析构函数也是一样的道理，（p556）

给定一个基类的引用或指针，如何创建动态绑定的拷贝或者移动?（p562）
* 问题在于，如何为这个拷贝分配空间
* 使用一个虚函数clone来模拟虚拷贝，clone作为虚函数，能够动态分配动态绑定类型的对象
```C++
class Base
{
    Base* clone() const & {return new Base(*this);}
    Base* clone() && {return new Base(std::move(*this));}
};
class Drived : Base
{
    Drived* clone() const & {return new Drived(*this);}
    Drived* clone() && {return new Drived(std::move(*this));}
}
```
<font color = green>End of Chapter</font>

### 第十六章 模板与泛型编程

模板函数可以针对调用进行参数推断，但模板类必须显式声明模板参数（p583）

模板成员函数只有在被使用时才会进行实例化，因此即使某种类型不能完全符合模板类的操作，也可以用该类型实例化该类（p589）

C++的类中除了成员变量外还可以定义类型变量，如using size_type = int;但在模板类实例化以前，编译器并不知道通过成员访问符获取的对象是否是类型，如T::size_type，若明确应该使用类型变量，则使用typename T::size_type 显式声明，不能使用class（p593）

模板实例化离不开<>，即使所有模板参数都有默认实参（p595）

为什么需要显式实例化（p598）
程序在每次需要使用模板时会生成模板的一个实例化，在多文件程序中，往往会对常用的类型生成多个实例化，浪费计算机资源，使用显式实例化后在需要使用的地方之前显式extern template + 声明就可以了。显式实例化会实例化所有的成员包括内联函数，因此必须确保实例化类型对所有成员都适用

unique_ptr在编译时绑定删除器，shared_ptr在运行时绑定删除器，前者降低了运行时开销，后者方便运行时重载（p600）

将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换以及数组或函数到指针的转换（使用其他的不能转换类型会生成新的实例），但对不是模板参数的类型，实参的类型转换是正常的（p601）

如果模板函数的返回值和参数列表不同时，返回值无法推导，需要显式声明fun<type>，注意这种情况只有当返回值对应模板参数在模板声明的第一个才有效，显式声明参数是按参数列表的声明顺序。此外，显式声明参数的类型可以进行正常类型转换。另一种情况是希望使用decltype根据形参类型推导返回值类型，此时使用后置返回值声明，就如lambda中一样（p604）
```C++
long lng;
compare(lng, 1024);         //error
compare<long>(lng, 1024);   //ok

//众所周知，C++会自动将整形常数1024推导为int，在第一个调用里，lng的类型固然是long，但此时1024推导为int时，并不知道模板实例化的第一个参数应该是long类型，于是类型不匹配，但对第二个调用，1024已经知道第一个参数应该是long，自己便会推导为long进行匹配
```
* 可以使用类型转换模板进行类型推导，可以实现去引用以返回拷贝
```C++
auto func(It beg) ->remove_reference<decltype(*beg)>::type
```

直接创建引用的引用是不合法的，但可以间接创建，如类型别名和模板参数，此时会发生引用折叠X& &, X& &&, X&& & -> X&; X&& && -> X&&，因此，对T&&这样的模板参数传递实参时，左值右值都可以，左值会变为T->type&, type& && -> type&，而对右值引用参数传入左值引用会导致类型T的实例化变成引用导致错误（如果本来希望T的变量只是拷贝的话），因此还是应该类似构造函数一样，分别重载左值和右值引用（p610）

标准库对move的定义
```C++
template<typename T>
typename remove_reference<T>::type&& move(T &&t)
{
    return static_cast<typename remove_reference<T>::type&&> (t);
}
//伟大，无需多言
```

完美转发（p614）                                
当使用模板函数接收一个函数指针以及对应参数，在函数中执行函数时，我们希望参数的传递保持原参数的所有信息，包括const，引用，使用引用折叠完成
```C++
template <typename F, typename T1, typename T2>
void flip(F f, T1 &&t1, T2 &&t2)
{
    f(std::forward<T2>(t2), std::forward<T1>(t1));
    //std::forward类似std::remove_reference，但这里是加一层右值引用
}
```

重载函数首先进行精确匹配，如果匹配程度一致，更倾向于选择特例化的版本，即适用性更狭隘的版本。注意并不是优先选择非模板函数，只是匹配程度一致的情况下优先。在定义任何重载函数之前，记得声明所有的重载版本，否则编译器可能自己在没有找到精确匹配的情况下生成意料之外的模板重载版本（p617）

可以使用sizeof...()返回可变参数包的参数个数（p619）

对可变参数包进行扩展，提供一个模式，把包拆开对所有类都应用模式（p621）
```C++
template<typename T, typename... Args>
ostream & print(ostream &os, const T &t, const Args&... rest)
{
    os << t << ", ";
    return print(os, pattern(rest)...);//注意...的位置
    //可变参数模板的递归调用，注意还需要一个调用单个可变参数的函数模板
}
```

实例化，特例化和重载的区别（p625）                      
* 实例化：模板根据给定的或推导但是类型，结合泛型的定义，得到实际的函数
* 特例化：模板对一些特定参数类型，由用户编写的改变了定义的特殊函数，但本质还是特殊的实例化，不影响参数匹配，特例化前加template<>
    - 可以对类模板部分特例化（如remove_reference的实现），不能对函数模板特例化
    - 对类模板成员的特例化与模板类无关，只有在实例化对应类型的模板类时才用该特例化进行实例化
* 重载：与模板无关，只对给定的类型执行操作的函数，影响函数匹配，即在同一匹配程序下优先

<font color = green>End of Chapter</font>

## 高级主题

### 第十七章 标准库特殊设施

tuple：快速随意的数据结构，并非定义了某个数据结构（p636）
* tuple<T1, T2, T3 ...>t(v1, v2, v3 ...) 实参默认时进行值初始化
* make_tuple(v1, v2, v3...)
* == > <
* get< i >(t) 获得t的第i个成员的引用
* tuple_size<tupleType>::value 返回成员数量，本质是个模板类
* tuple_element<i, tupleType>::type 返回第i个成员类型，模板类

bitset：方便的使用二进制表示（p640）

正则表达式，就是编译原理里那些东西（p645）

随机数（p660）
* C++定义了新的随机数系统，使用户可以方便的控制随机数产生的范围
* 多个随机引擎类，默认为default_random_engine
    - Engine e(s);  以s为种子，无参数时使用默认的种子
    - e.seed(s)     以s为种子重置引擎
    - e.min() e.max()   可生成的最大最小值
    - Engine::result_type   引擎生成的unsigned整数类型
    - e.discard(u)  将引擎推进u步
* 分布对象d，控制生成数的分布情况
    - Dist d    
    - d(e)
    - d.min(), d.max()
    - d.reset() 重建状态
    - C++不止定义了随机分布，还有正态分布以及返回bool的bernoulli_distribution
* 使用u(e)来结合分布对象和引擎获得生成数
* 重复调用有随机数生成的函数会得到相同的随机数生成，使用static保留状态来避免
* 如果希望每次运行时生成不同的结果，可以通过提供种子为time(0)实现，但time的返回以秒为单位，所以只使用生成种子有一定间隔的时候 

IO（p666）
格式化，未格式化，随机访问

<font color = green>End of Chapter</font>

### 第十八章 用于大型程序的工具

处理构造函数初始化值异常的唯一方法是将构造函数写成try语句块（p690）
```C++
template<typename T>
Blob<T>::Blob(std::initializer_list<T> il) try :
    data(std::make_shared<std::vector<T>>(il))
    {}
    catch(const std::bad_alloc &e) {handle_out_of_memory(e);}
```

异常类层次，可以定义自己的异常类（p693）

inline命名空间，可以被外层命名空间直接使用，只需要在声明时说明inline就可以了。未命名的命名空间，在特定的文件内部有效，不会横跨多个文件，多个文件的未命名命名空间互不相关，未命名空间可以直接访问，取代了C的static声明（p701）

避免using指示，一次性注入命名空间的所有名字容易造成污染，可以在命名空间本身的实现文件中使用using指示。在头文件中应该禁止在顶层作用域使用using声明和指示，因为这样会影响所有包含头文件的文件，而我们需要的仅仅只是负责定义接口部分的名字（p704）

命名空间有一些例外的实参查找，有时会根据实参自动匹配标准库(std)内的成员函数，如operator>>，在调用的时候一般不会特别进行using声明，但这只是例外。类似于move，forward这样的函数则没有这样的匹配，因为对他们的无意冲突更多，所以更推荐手动带上std::（p707）

使用using指示或声明可以扩展同名函数的重载，并且这种扩展只限定名字，会把所有的同名函数都作为候选，其中using指示不受同参数列表函数影响，只要在使用时指明调用的是哪个版本即可，但using声明对此情况是禁止的（p709）

如果在多重继承中使用using继承基类的同名函数，并且这些同名函数有相同的形参列表，就会因为二义性导致错误，必须定义一个派生类自己的该形参列表函数；此外多重继承类绑定到自己的基类指针和引用时，优先级一致，因此可能出现二义性函数（p713）

解决二义性的最好方法是为派生类定义自己的版本（p719）

虚拟继承类的初始化列表先初始化虚基类子部分，接下来按直接基类在派生类列表中出现的顺序依次初始化，虚基类总是先于非虚基类构造，和继承次序无关（p720）

<font color = green>End of Chapter</font>

### 第十九章 特殊工具与技术

可以在全局作用域或者类作用域中声明自己的operator new和operator delete重载，但在类作用域中声明时，它们是隐式静态的，显式声明当然也没错，原因是operator new执行于类创建之前，operator delete执行于类销毁之后。此外这里的operator new和new不是重载的关系，operator new指的是new里面分配内存的动作，在此之后还要进行构造函数。delete同理。不能重载new和delete的行为，只能重载分配和释放内存时的行为（p727）                                     
更具体的来说，new和delete都可以看做两个部分
* new 先使用operator new分配空间，然后进行构造函数
    - 如果是手动调用operator new分配空间的话，类似于alloc，但是不能使用construct构造，而要使用定位new来构造
* delete 先调用析构函数，然后使用operator delete释放空间
    - 手动调用析构函数清除了对象，但并不会释放内存

运行时类型识别 RTTI（p730）
* dynamic_cast 把基类指针安全的转换为派生类指针，调用那些想要派生版本的非虚函数，被转换的指针必须是目标的公有基类，公有派生类或者本身
* typeid
    - typeid(e)，返回type_info的引用，e是类型或者表达式，常用来比较类型是否一致
    - 忽略顶层引用，不会执行函数和数组的指针转换，使用*p 返回p的动态类型，如果只是作用于指针则是指针的静态类型
使用RTTI
```C++
//判断一系列派生类是否相等的例子
//首先，如果类型不同，必然返回false
//如果类型相同，则调用虚函数equal，把右参数转换为动态类型指针，进行比较
//每个派生类有自己的equal，但共用一个operator==
bool operator==(const Base &lhs, const Base &rhs)
{
    return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);
}

bool Derived::euqal(const Base &rhs) const
{
    auto r = dynamic_cast<const Derived&>(rhs);
    //通过r访问rhs的继承成员
}
```
* type_info类

enum e : int_type {}指定枚举成员的潜在类型，保证在不同环境实现一致。不限定作用域时声明必须指定成员大小，限定作用域(enum class)时默认为int（p737）

类成员指针，可以应用于类的数据成员和函数成员，类似于添加了一个类的成员变量指向某个成员，通过对象或者对象指针的(.\*/->\*)访问。一般通过auto声明，并且在使用时函数要加括号(T.\*p)()，T.\*p()是错误的，适用于需要把类的函数取出来选择调用的时候，使用bind或者mem_fn可以取出类的函数成员并且把类对象本身作为参数绑定（p744）

嵌套类，在类中声明，类外或类内定义，类似于has-a的关系，于外层类隔离开，没什么联系，更多作为实现的定义。局部类，定义在函数中，不能含有静态数据成员，所有成员都必须在类中定义，不能访问猜测函数的非静态变量（p748）

union默认成员为public，不能作为基类，不能继承，没有虚函数，当成员为定义了构造函数和析构函数的对象时行为变得复杂，可以用类来管理union，包含一个判别式成员，追踪union当前保存的状态。未命名的union在类中声明，会自动创建一个实例（p751）

使用volatile禁止优化时，合成的拷贝对该对象无效（p758）

<font color = green>End of Chapter</font>