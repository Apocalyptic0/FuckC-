Fuck C++
1. C++ Prime Plus
2. C++ Primer
3. <font color = pink>Efficient C++</font>
4. 
5. 
6. 

## Efficient C++
last update:2024/1/30 15:08 Full Combo!

### 条款01：视C++为一个语言联邦
### 条款02：尽量以const enum inline 替换 #define
#define的缺点：
* 编译器无法识别define的符号，只是简单替换，如果出现了问题难以寻址
* 预处理器无视作用域，换句话说无法声明class的define
* 定义宏时直接替换带来无法避免的错误，使用inline的template吧
const的缺点：
* 能够获取访问const的地址和引用，这一点和define不像
* 类内初始化是C++11才支持的，编译器不一定支持，并且如果要在不同文件使用类的const，可能需要多次声明
* 因此如果需要在类里定义一个常量并使用，使用enum hack吧，它更像define
### 条款03：尽可能使用const
在应该为const的地方使用const，有利于编译器发现错误。区分顶层const和底层const，const可施加于常量，对象，参数，返回值，成员函数。对const成员函数，编译器实施bitwise constness，即保证类的成员的每个比特不变，这样有一定问题，应该注意类中指针指向的conceptal constness，也可以使用mutable控制一些可变的变量。编写同一成员函数的const和非const版本时，可以考虑使用const_cast转换在非const版本中调用const版本，反之不行，const代表安全。
### 条款04：确定对象使用前已先被初始化
手动初始化内置类型

使用初始化列表往往高效且必要，构造函数中进行的是赋值操作，初始化在构造函数前进行，如果没有初始化列表对象将调用默认构造函数，并且即使是内置类型，如果是const或reference，也只能在初始化列表进行。C++的初始化顺序固定，但允许初始化列表顺序随意，因此最好按照声明顺序编写初始化列表                                               
但也有例外，如果类的变量过多，需要多个针对不同变量的构造函数，也可以把公共部分写在一个private函数中通过构造函数调用

注意初始化次序不确定性 对不同编译单元定义的non-local static，可以使用singleton避免，C++不保证不同编译单元的non-local static的定义顺序，但保证函数内的static在调用时初始化

### 条款05：了解C++默默编写并调用那些函数
class会自动生成默认构造函数，拷贝构造函数，赋值构造函数，析构函数，在能生成的时候。其中，析构函数是non-virtual，除非从base继承；所有的构造函数进行的都是bit的复制，也就是浅拷贝，赋值构造语句无法处理const和引用；使用private阻止编译器生成这些函数
### 条款06：若不想使用编译器自动生成的函数，就该明确拒绝
使用private阻止编译器生成函数有个缺点：friend函数仍可以调用，可以通过继承一个Uncopyable基类来解决，调用构造函数时会访问基类，基类会将其阻止调用。也可以使用Boost的noncopyable
### 条款07：为多态基类声明virtual析构函数
应该为带多态性质的基类声明virtual析构函数，virtual析构函数从继承底层往上调用，因此对pure virtual析构函数需要给出一个定义；相反，不应该将所有析构函数声明为virtual，因为这样会带来更大的占用空间，因为存储了无用的虚表
### 条款08：别让异常逃离析构函数
通过类的其他成员函数进行析构函数中进行的带异常操作可以为用户提供解决问题的机会，如果用户坚信不会出现问题也可以在析构函数中调用。析构函数绝对不要抛出异常，否则会导致不明确的执行，应该对可能的异常进行捕捉并吞下或结束
### 条款09：绝不在构造和析构过程中调用virtual函数
在base class构造期间，virtual函数不会下降到派生调用，换句话说，virtual函数不再virtual，因为派生部分的内容还未生成。析构函数同理，如果需要一些初始化工作，可以使用非虚函数传递参数的方式
### 条款10：令operator= 返回一个 reference to *this
### 条款11：在operator= 中处理 “自我赋值”
比较来源和目标的地址，先保存原数据再赋值，拷贝并交换（可以使用value传递）。总之就是确保函数处理多个对象，而多个对象中有相同时的正确性
### 条款12：复制对象时勿忘其每一个成分
不能在赋值构造函数中使用拷贝构造函数，反之亦然，对赋值构造函数的基类赋值，应该直接调用基类的赋值构造，如Base::operator=(rhs);如果二者有相同部分，应该采用第三个公共函数

### 条款13：以对象管理资源
使用对象管理资源以处理好内存回收，例如智能指针
### 条款14：在资源管理类中小心coping行为
禁止copy，引用计数，深拷贝
### 条款15：在资源管理类中提供对原始资源的访问
隐式还是显式呢
### 条款16：成对使用new和delete时要采取相同形式
new/delete new type[]/delete[]
### 条款17：以独立语句将newed对象置入智能指针
processWidget(std::tr1::shared_ptr<Widget>(new Widget), priority()); //会造成资源泄露   new, priority(异常), ->shared                            
实际上应该使用std::make_shared或在前方定义独立语句，见下一本书对new和make构造智能指针的讨论

### 条款18：让接口容易被正确使用，不易被误用
### 条款19：设计class犹如设计type
### 条款20：宁以pass-by-reference-to-const替换pass-by-value
### 条款21：必须返回对象时，别妄想返回其reference
### 条款22：将成员变量声明为private
### 条款23：宁以non-member、non-friend替换member函数
简单来说就是尽可能的增加封装性
### 条款24：若所有参数皆需类型转换，请为此采用non-member函数
operator+ 需要类型转换是典型例子 
### 条款25：考虑写出一个不抛异常的swap函数
普通的swap意味着三次构造函数，构造函数意味着可能的异常。那么，在swap代价过大时（pimpl），使用自定义成员swap和非成员swap，对class可以在std中特例化swap，但对函数模板不可偏特化，std中也不可重载，正确的做法是在模板的命名空间加入非成员swap，让编译器在调用时自动匹配。当然需要正确的调用方式，using std::swap;swap(a,b);

### 条款26：尽可能延后变量定义式的出现时间
* 将变量定义于循环外 1个构造函数+1个析构函数+n个赋值构造
* 将变量定义于循环内 n个构造函数+n个析构函数
* 抛开效率不谈，定义在内更好，正如这个条款所说
### 条款27：尽量少做转型操作
static_cast<Base>(derived).fun();    使用*this转型后的临时Base对象调用，和derived无关，正确的做法是 Base::fun();                            
static_cast支持向上转型，dynamic支持向下转型，并且通常应该用virtual函数代替
转型是危险的操作，把他们封装起来
### 条款28：避免返回handles指向对象内部成分
容易出现封装和悬挂问题
### 条款29：为“异常安全”而努力是值得的
异常安全的三个保证（提供其中之一）
* 基本承诺：异常抛出时处于有效状态，但是这个有效状态是未知的，只是保证没有损坏
* 强烈保证：要么运行成功，要么保持运行前原样    CAS
* 不抛掷保证：承诺永不抛出异常
### 条款30：透彻了解inlining的里里外外
可以使用函数指针指向inline函数，这样会为inline函数添加一个实体，并且使用指针调用inline函数通常不会inline                    
inline函数的修改会导致重新编译
### 条款31：将文件间的依存关系降至最低
* 为声明式和定义式提供两个头文件
* pimpl
* interface class

### 条款32：确定你的public继承塑造出is-a关系
is-a代表public继承，代表B能做的D也一定能做
### 条款33：避免遮掩继承而来的名称
使用using或转交函数拯救D类中被重载掩盖的B类成员
### 条款34：区分接口继承和实现继承
* pure virtual：只具体指定接口继承，但也可以拥有实现，通过base::fun调用，并且这是一个把需要基类默认实现但继承类实现缺失错误提到编译期的方法
* impure virtual：指定接口继承和缺省实现继承
* non-virtual：指定接口继承和强制实现继承（不变性）
### 条款35：考虑virtual函数外的其他选择
* NVI non-virtual interface
* virtual替换为函数指针成员或function成员       对private数据的访问权限？
* virtual替换为另一个继承体系的virtual函数，拥有另一个体系的成员
--Strategy设计模式
### 条款36：绝不重新定义继承而来的non-virtual函数
### 条款37：绝不重新定义继承而来的参数缺省值
具体的说，缺省值静态绑定，virtual函数动态绑定，那么，使用NVI吧
### 条款38：通过复合塑模出has-a或“根据某物实现出”
复合：private成员
### 条款39：明智而审慎地使用private继承
private继承意味着继承实现而不继承接口，只有两个理由使你应该选择它而不是复合：
* 需要base的protected成员和需要virtual函数
* 对empty类的单一继承应用EBO（empty base optimization）
### 条款40：明智而审慎地使用多重继承
* virtual继承保证了重复变量的单次获取，但有一定代价，正如virtual函数也有一定代价
* 使用多重继承的一个例子 public继承一个接口类，private继承一个协助实现的类

### 条款41：了解隐式接口与编译期多态
模板代表隐式接口和编译期多态
### 条款42：了解typename的双重意义
C++不会把嵌套从属名称推导为类型，需要手动添加typename，但是在继承的基类列和成员初始化列表中不能出现。除此之外，template里的typename和class完全一致
### 条款43：学习处理模板化基类的名称
编译器不会进入模板的基类中查找，在继承类模板中调用基类的成员，可以使用this，using或base::，最后一种做法会解除virtual绑定
### 条款44：将与参数无关的代码抽离template
* 非类型模板参数：使用成员变量或函数参数消除
* 类型参数：带有完全相同二进制表述的具现类型共享实现码
### 条款45：运用成员函数模板接受所有的兼容类型
智能指针实现可转换类型进行参数传递的方法（例如把derived指针传入base类智能指针），如果使用了泛化构造，需要同时声明普通的和泛化的copy和赋值构造函数
### 条款46：需要类型转换时请为模板定义非成员函数
正如24所说，非成员函数才能支持所有类型转换，但当来到模板的世界，类型转换需要把函数放在类里面，于是使用friend声明                  
事实上当把函数放在类里面时，类生成时便创建了这个函数（特例化），使用已有的函数隐式转换当然没问题，前提是这个创建的函数需要有定义（在类中定义的原因）
### 条款47：请使用traits classes表现类型信息
* 一组重载函数或函数模板，使用一个traits匿名参数来区分不同的实现
* 一个控制函数，通过traits参数确定调用那个函数
overload使得traits在编译期进行
* 此外，使用typeid实现的if判定会导致编译错误，因为编译器保证所有代码有意义，即使不执行的代码
### 条款48：认识模板元编程
看不懂，思密达

### 条款49：了解new-handler的行为
set-new-handler
### 条款50：了解new和delete的合理替换时机
* 检测错误
* 强化效能
* 收集信息
### 条款51：编写new和delete时需墨守常规
* operator new：一个无穷循环，在其中尝试分配内存，如果无法满足则调用new-handler，处理0bytes申请，处理继承类（更大）
* operator delete：处理null（不做任何事），处理继承类
### 条款52：写了placement new也要写placement delete
placement代表额外的参数，当然一般是一个void*（定位），当new的构造函数抛出异常时，C++自动调用相应的delete，当然前提是它找得到，因此placement new必须有一个placement delete。此外，注意不要让特殊的new delete在类中掩盖了他们的正常版本
* 使用::全局作用域符在这些自定义new中使用原始版本 ::operator new(size)

### 条款53：不要轻忽编译器的警告
### 条款54：让自己熟悉包括TR1在内的标准程序库
### 条款55：让自己熟悉Boost